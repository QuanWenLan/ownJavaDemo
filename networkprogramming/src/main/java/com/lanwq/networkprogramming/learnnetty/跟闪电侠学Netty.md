#### 粘包、半包现象  

尽管我们在应用层面使用了Netty，但是操作系统只认TCP协议；尽管我们的应用层按照ByteBuf为单位来发送数据，但是到了底层操作系统，仍然是按照字节流发送数据的，因此，数据到了服务端，也按照字节流的方式读入，然后到了Netty应用层面，重新拼装成ByteBuf。  
这里的ByteBuf与客户端按照顺序发送的ByteBuf可能是不对等的。因此，我们需要在客户端根据自定义协议来组装应用层的数据包，
然后在服务端根据应用层的协议来组装数据包，这个过程通常在服务端被称为拆包，而在客户端被称为粘包。  

拆包和粘包是相对的，一端粘了包，另外一端就需要将粘过的包拆开。举个例子，发送端将三个数据包粘成两个TCP数据包发送到接收端，接收端就需要根据应用协议将两个数据包重新拆分成三个数据包。  

拆包的原理  
在没有Netty的情况下，用户如果自己需要拆包，基本原理就是不断地从TCP缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包。  
1.如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从TCP缓冲区中读取，直到得到一个完整的数据包。  
2.如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，构成一个完整的业务数据包传递到业务逻辑，
多余的数据仍然保留，以便和下次读到的数据尝试拼接。  

Netty 自带的拆包器
1. 固定长度的拆包器FixedLengthFrameDecoder  
如果应用层协议非常简单，每个数据包的长度都是固定的，比如100，那么只需要把这个拆包器加到Pipeline中，Netty就会把一个个长度为100的数据包（ByteBuf）
传递到下一个ChannelHandler。  
2. 行拆包器LineBasedFrameDecoder
从字面意思来看，发送端发送数据包的时候，每个数据包之间以换行符作为分隔，接收端通过LineBasedFrameDecoder将粘过的ByteBuf拆分成一个个完整的应用层数据包。
3. 分隔符拆包器DelimiterBasedFrameDecoder
DelimiterBasedFrameDecoder是行拆包器的通用版本，只不过我们可以自定义分隔符。
4. 基于长度域的拆包器LengthFieldBasedFrameDecoder
最后一种拆包器是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。

#### ChannelHandler 生命周期
##### 连接时执行顺序：
1. handlerAdded()：指当检测到新连接之后，调用ch.pipeline().addLast(new LifeCyCleTestHandler());之后的回调，表示在当前Channel中，已经成功添加了一个Handler处理器。
2. channelRegistered()：这个回调方法表示当前Channel的所有逻辑处理已经和某个NIO线程建立了绑定关系，接收新的连接，然后创建一个线程来处理这个连接的读写，只不过在Netty里使用了线程池的方式，只需要从线程池里去抓一个线程绑定在这个Channel上即可。这里的NIO线程通常指NioEventLoop。
3. channelActive()：当Channel的所有业务逻辑链准备完毕（即Channel的Pipeline中已经添加完所有的Handler），以及绑定好一个NIO线程之后，这个连接才真正被激活，接下来就会回调到此方法。
4. channelRead()：客户端向服务端发送数据，每次都会回调此方法，表示有数据可读。
5. channelReadComplete()：服务端每读完一次完整的数据，都回调该方法，表示数据读取完毕。
##### 关闭时执行顺序  
1. channelInactive()：表面上这个连接已经被关闭了，这个连接在TCP层面已经不再是ESTABLISH状态了。
2. channelUnregistered()：既然连接已经被关闭，那么与这个连接绑定的线程就不需要对这个连接负责了。这个回调表明与这个连接对应的NIO线程移除了对这个连接的处理。
3. handlerRemoved()：我们给这个连接添加的所有业务逻辑处理器都被移除。

